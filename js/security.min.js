/* MenuLabus - Optimized */
function isCryptoAvailable(){return"undefined"!=typeof window&&window.crypto&&window.crypto.subtle&&void 0!==window.TextEncoder}async function hmac(n,t){try{const e=new TextEncoder,r=e.encode(n),o="string"==typeof t?t:JSON.stringify(t),i=await crypto.subtle.importKey("raw",r,{name:"HMAC",hash:"SHA-256"},!1,["sign"]);return arrayBufferToHex(await crypto.subtle.sign("HMAC",i,e.encode(o)))}catch(n){throw new Error("SIGNATURE_FAILED")}}function encodeUnicode(n){return btoa(encodeURIComponent(n).replace(/%([0-9A-F]{2})/g,(n,t)=>String.fromCharCode("0x"+t)))}function decodeUnicode(n){return decodeURIComponent(atob(n).split("").map(n=>"%"+("00"+n.charCodeAt(0).toString(16)).slice(-2)).join(""))}async function signData(n,t){if(!n||!t)throw new Error("INVALID_INPUT");try{const e=JSON.stringify(n),r=await hmac(t,e);return`${encodeUnicode(e)}.${r}`}catch(n){throw new Error("SIGNATURE_FAILED")}}async function verifiedData(n,t){if(!n||!t)return null;const e=n.split(".");if(2!==e.length||!e[0]||!e[1])return null;const[r,o]=e;try{const n=decodeUnicode(r);return o!==await hmac(t,n)?null:JSON.parse(n)}catch(n){return null}}function arrayBufferToHex(n){try{const t=new Uint8Array(n);return Array.from(t).map(n=>n.toString(16).padStart(2,"0")).join("")}catch(n){throw new Error("ENCODING_FAILED")}}"undefined"!=typeof window&&(window.Security=window.Security||{},window.Security.signData=signData,window.Security.verifiedData=verifiedData),"undefined"!=typeof module&&module.exports&&(module.exports={signData:signData,verifiedData:verifiedData});