/* MenuLabus - SSE with polling fallback */
(function () {
  "use strict";

  var lastTimestamp = 0;
  var pollAbortController = null;
  var pollingActive = false;
  var source = null;
  var reconnectTimer = null;

  var isEmployeePage = document.body.classList.contains("employee-page");
  var isCustomerOrdersPage = document.body.classList.contains("customer_orders-page");
  var isAdminFormContainer = document.body.classList.contains("admin-form-container");
  var cartTotalCountEl = document.getElementById("cart-total-count");
  var lastRefreshAt = 0;
  var refreshScheduled = false;
  var refreshInFlight = false;

  function rebindOrderInteractions() {
    // Intentionally left minimal.
    // account.min.js uses event delegation for these pages; rebinding/cloning can freeze low-end devices.
  }

  function replaceSectionFromHtml(containerSelector, html) {
    var parser = new DOMParser();
    var parsed = parser.parseFromString(html, "text/html");
    var next = parsed.querySelector(containerSelector);
    var current = document.querySelector(containerSelector);
    if (!next || !current) {
      return;
    }

    var activeTab = document.querySelector(".tab-btn.active");
    var activeTabName = activeTab ? activeTab.dataset.tab : null;

    current.outerHTML = next.outerHTML;

    if (activeTabName) {
      var tabButton = document.querySelector('.tab-btn[data-tab="' + activeTabName + '"]');
      var tabPane = document.getElementById(activeTabName);
      if (tabButton) tabButton.classList.add("active");
      if (tabPane) tabPane.classList.add("active");
    }
  }

  function refreshOrdersHtml() {
    // Avoid stacking multiple full-page HTML fetches (can freeze low-end devices).
    var now = Date.now();
    var minInterval = (isEmployeePage || isCustomerOrdersPage) ? 5000 : 2000;
    if (now - lastRefreshAt < minInterval) {
      return;
    }
    if (refreshInFlight) {
      return;
    }
    lastRefreshAt = now;
    refreshInFlight = true;

    // Fetch only the section we need on orders pages to keep HTML small and parsing fast.
    var url = location.href;
    if (isEmployeePage || isCustomerOrdersPage) {
      url = location.pathname + (location.search ? location.search + "&" : "?") + "partial=account-sections&_=" + now;
    }

    fetch(url, { cache: "no-store", credentials: "same-origin" })
      .then(function (r) {
        // If session expired and server redirects to auth.php, do not parse/replace DOM repeatedly.
        if (r.redirected && r.url && r.url.indexOf("/auth.php") !== -1) {
          window.location.href = "/auth.php?mode=login";
          throw new Error("auth_redirect");
        }
        return r.text();
      })
      .then(function (html) {
        if (isEmployeePage || isCustomerOrdersPage) {
          replaceSectionFromHtml(".account-sections", html);
        } else if (isAdminFormContainer) {
          replaceSectionFromHtml(".orders-list", html);
        }
      })
      .catch(function () {
        // no-op
      })
      .finally(function () {
        refreshInFlight = false;
      });
  }

  function scheduleRefresh() {
    if (refreshScheduled) {
      return;
    }
    refreshScheduled = true;
    setTimeout(function () {
      refreshScheduled = false;
      if (document.hidden) {
        return;
      }
      refreshOrdersHtml();
    }, 200);
  }

  function handlePayload(payload, opts) {
    opts = opts || {};
    var allowRefresh = opts.allowRefresh !== false;

    if (!payload || typeof payload !== "object") {
      return;
    }

    if (payload.timestamp && payload.timestamp > lastTimestamp) {
      lastTimestamp = payload.timestamp;
    }

    if (cartTotalCountEl && typeof payload.cartTotal !== "undefined") {
      cartTotalCountEl.textContent = payload.cartTotal;
    }

    if (!allowRefresh) {
      return;
    }

    if (!payload.orderUpdated) {
      return;
    }

    if (isEmployeePage || isAdminFormContainer) {
      scheduleRefresh();
      return;
    }

    if (isCustomerOrdersPage) {
      var shouldRefresh = false;
      var currentOrderItems = document.querySelectorAll(".order-item");
      currentOrderItems.forEach(function (item) {
        var id = parseInt(item.dataset.orderId || "0", 10);
        if (Array.isArray(payload.changedOrderIds) && payload.changedOrderIds.indexOf(id) !== -1) {
          shouldRefresh = true;
        }
      });

      // Only refresh when server provides concrete changed IDs.
      // An empty/missing list should not trigger full HTML reloads on every ping.
      if (shouldRefresh) {
        scheduleRefresh();
      }
    }
  }

  function startPolling() {
    if (pollingActive) {
      return;
    }
    pollingActive = true;

    function run() {
      if (pollAbortController) {
        pollAbortController.abort();
      }
      pollAbortController = new AbortController();

      fetch("/ws-poll.php?t=" + lastTimestamp, { signal: pollAbortController.signal, cache: "no-store", credentials: "same-origin" })
        .then(function (response) {
          if (!response.ok) {
            throw new Error("http " + response.status);
          }
          return response.json();
        })
        .then(function (payload) {
          handlePayload(payload);
        })
        .catch(function () {
          // no-op
        })
        .finally(function () {
          var delay = document.hasFocus() ? 15000 : 60000;
          setTimeout(run, delay);
        });
    }

    run();
  }

  function scheduleReconnect() {
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
    }
    reconnectTimer = setTimeout(function () {
      startSSE();
    }, 3000);
  }

  function startSSE() {
    if (!("EventSource" in window)) {
      startPolling();
      return;
    }

    if (source) {
      source.close();
    }

    var opened = false;
    source = new EventSource("/orders-sse.php?t=" + lastTimestamp);

    source.onopen = function () {
      opened = true;
    };

    source.addEventListener("update", function (event) {
      try {
        handlePayload(JSON.parse(event.data), { allowRefresh: true });
      } catch (e) {
        // no-op
      }
    });

    source.addEventListener("ping", function (event) {
      try {
        // Ping is for keeping connection alive and syncing timestamps; never force refresh.
        handlePayload(JSON.parse(event.data), { allowRefresh: false });
      } catch (e) {
        // no-op
      }
    });

    source.onerror = function () {
      if (source) {
        source.close();
      }

      // If SSE cannot establish connection at all, fallback to polling.
      if (!opened) {
        startPolling();
      } else {
        scheduleReconnect();
      }
    };

    // If nothing opened shortly after init, fallback to polling.
    setTimeout(function () {
      if (!opened && !pollingActive) {
        if (source) source.close();
        startPolling();
      }
    }, 8000);
  }

  window.addEventListener("load", function () {
    rebindOrderInteractions();
    startSSE();
  });
})();
